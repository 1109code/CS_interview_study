# 3주차: 알고리즘

# 시간복잡도

시간복잡도 : 연산의 횟수를 점근적 표기법을 통해 추상적으로 표현

- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산 (명령문 = 연산)

시간 복잡도 ≒ (빅-오(O) 표기법) - 이 외에도 Big- Ω, Big-Θ  표기법이 있다.

- 빅-오 표기법(Big-Oh Notation)
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수 (Coefficient)는 생략하여 표시

약 10억번의 계산에 1초가 걸린다고 생각할 수 있다.

Big-O : 최악의 경우 ?번 수행되면 프로그램을 끝낼 수 있다

![https://blog.kakaocdn.net/dn/bpoQ1P/btrJKsFdpl3/8SCK0QoWHOjOCBuX8KTNKk/img.jpg](https://blog.kakaocdn.net/dn/bpoQ1P/btrJKsFdpl3/8SCK0QoWHOjOCBuX8KTNKk/img.jpg)

Big-Omega :최소 ?번은 수행되어야 프로그램을 끝낼 수 있다

![https://blog.kakaocdn.net/dn/v2xhj/btrJGT4m6jn/pGZOx9UDVfsKRFK1VmBtb0/img.jpg](https://blog.kakaocdn.net/dn/v2xhj/btrJGT4m6jn/pGZOx9UDVfsKRFK1VmBtb0/img.jpg)

Big-Theta : 최소와 최악의 평균적인 복잡도

![https://blog.kakaocdn.net/dn/DDKGY/btrJItYHkCy/KQtjGxyEmS1UkJMLYui0K1/img.jpg](https://blog.kakaocdn.net/dn/DDKGY/btrJItYHkCy/KQtjGxyEmS1UkJMLYui0K1/img.jpg)

# 정렬(버블, 선택, 퀵, 병합, 삽입)

단순(구현 간단)하지만 비효율적인 방법

- 삽입 정렬, 선택 정렬, 버블 정렬

복잡하지만 효율적인 방법

- 퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/94997112-ec6a-4ff8-a6d2-81fa8b03f08b/Untitled.png)

## 퀵 정렬

분할 정복 알고리즘의 하나, 평균적으로 매우 빠른 수행 속도를 가진다

병합 정렬과 달리 퀵 정렬은 리스트를 비균등하게 분할

분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할

정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용

결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병

순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

## 선택 정렬

제자리 정렬(in-place sorting) 알고리즘의 하나

입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법

해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘

첫 번째 순서에는 첫 번째 위치에 가장 최솟값을 넣는다.

두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.

…

과정 설명

- 주어진 배열 중에서 최솟값을 찾는다.
- 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
- 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체
- 1개의 원소만 남을 때까지 위의 과정을 반복

```python
def SelectionSort(A):
	n = len(A)
	for i in range(0, n - 1):
		minI = i
		for j in range(i + 1, n):
			if A[j] < A[minI]"
				minI = j
		A[minI], A[i] = A[i], A[minI]
```

### 시간복잡도

비교 횟수

- 두 개의 for 루프의 실행 횟수
- 외부 루프: (n-1)번
- 내부 루프(최솟값 찾기): n-1, n-2, … , 2, 1 번

교환 횟수

- 외부 루프의 실행 횟수와 동일. 즉, 상수 시간 작업
- 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 3(n-1)번
- T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = **O(n^2)**

## 병합정렬

시간복잡도 : O(nlogn)

### 병합 정렬 과정

- {9, 10, 2, 13, 16, 8, 31, 22}를 병합 정렬하는 과정
- 분할 단계: 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업을 계속한다.
- 병합 단계: 2개의 부분집합을 정렬하면서 하나의 집합으로 병합
- 8개의 부분집합이 1개로 병합될 때까지 반복함

### 분할과정

```html
merge_sort(LIST m) IF length(m) == 1: RETURN m LIST left, right middle <-
length(m) /2 FOR x in m berfore middle add x to left FOR x in m after or equal
middle add x to right left <- merge_sort(left) right <- merge_sort(right) RETURN
merge(left, right)
```

### 병합과정

```html
merge(LIST left, LIST right) LIST result WHILE length(left) > 0 OR length(right)
> 0 IF length(left) > 0 ANS length(right) > 0 IF first(left) <= first(right)
append popfirst(left) to result ELSE append popfirst(right) to result ELIF
length(left) > 0 append popfirst(left) to result ELIF append popfirst(right) to
result RETURN result
```

# 재귀

### 재귀: 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법

- 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
- 재귀 함수로 구현

재귀 함수 (recursive function)

- 함수 내부에서 직/간접적으로 자기 자신을 호출하는 함수
- 기본 부분(basis part)와 유도 부분(inductive part)로 구성됨
- 함수 호출은 프로그램 메모리 구조에서 스택 이용
- 재귀 호출은 반복적인 스택의 사용으로 메모리 및 속도에서 성능저하가 발생할 수 있다.

# DP

# 그래프 기초(dfs, bfs, 백트래킹)

### DFS(깊이우선탐색)

- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용

## BFS(Breadth First Search)

- 너비우선탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작저믕로 하여 다시 인접한 정점들을 차례로 방문하는 방식
- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출형태의 자료구조인 큐를 활용함

# MST(최소 신장 트리)

- 그래프에서 최소 비용 문제
  - 1. 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - 2. 두 정점 사이의 최소 비용의 경로 찾기
- 신장 트리
  - n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리(Minimum Spanning Tree)
  - 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리

### Prim 알고리즘

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어가는 방식1) 임의 정점을 하나 선택해서 시작2) 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택3) 모든 정점이 선택될 때 까지 1), 2), 과정을 반복
- 서로소인 2개의 집합(2, disjoint-sets) 정보를 유지
  - 트리 정점들(tree vertices) - MST를 만들기 위해 선택된 정점들
  - 비트리 정점들(nontree vertices) - 선택 되지 않은 정점들

### KRUSKAL 알고리즘

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘1) 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬2) 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
  - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택3) n-1 개의 간선이 선택될 때까지 2)를 반복

# 그래프 심화 (벨만포드/다익스트라/플로이드와샬)

최단 경로

- 최단 경로 정의
  - 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로
- 하나의 시작 정점에서 끝 정점까지의 최단경로
  - 다익스트라(dijkstra) 알고리즘
    - 음의 가중치를 허용하지 않음
  - 벨만-포드(Bellman-Ford) 알고리즘
    - 음의 가중치 허용
- 모든 정점들에 대한 최단 경로
  - 플로이드-워샬(Floyd-Warshall) 알고리즘

### Dijkstra 알고리즘

- 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식이다.
- 시작정점(s) 에서 끝정점(t) 까지의 최단 경로에 정점 x가 존재한다.
- 이때, 최단경로는 s에서 x까지의 최단 경로와 x에서 t까지의 최단경로 구성된다.
- 탐욕 기법을 사용한 알고리즘으로 MST의 프림 알고리즘과 유사하다

# 분할정복/이분탐색

## 분할정복

### 설계 전략

- 분할 : 해결할 문제를 여러 개의 작은 부분으로 나눈다.
- 정복 : 나눈 작은 문제를 각각 해결한다.
- 통합 : (필요하다면) 해결된 해답을 모은다.

분할 정복 방법은 대개 순환 호출을 이용하여 구현

# 그리디

탐욕 알고리즘의 필수 요소

### 탐욕적 선택 속성(greedy choice property)

- 탐욕적 선택은 최적해로 갈 수 있음을 보여라.
  - 즉, 탐욕적 선택은 항상 안전하다.

### 최적 부분 구조(optimal substructure property)

- 최적화 문제를 정형화하라
  - 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.

### [원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해] 임을 증명하라

매 단계에서 가장 좋게 보이는 것을 빠르게 선택한다.
