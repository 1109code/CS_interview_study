# 자료구조

```
   1. array vector linked list
   2. stack queue
   3. priority queue / deque
   4. hash
   5. heap
   6. graph
   7. tree 이진트리 완전이진트리 이진탐색트리
   8. avl / redblack tree
   9. union-find
```

## 1. Array, Vector, Linked list

✔ Array, Vector: 메모리 공간 기반의 연속 방식

✔ Linked List: 포인터 기반의 연결 방식

### Array(정적 배열)

✔ 정적 배열

✔ 크기를 지정하고 해당 크기만큼의 연속된 메모리 공간을 할당받는 자료형

✔ 한번 생성한 배열의 크기는 고정된다

✔ 조회: O(1) / 탐색: O(N)

✔ 삭제 / 삽입: O(N)
- 기존 원소들을 이동 시켜줘야된다.

```java

int[] numbers = new int[5];

numbers[0] = 10;
numbers[1] = 15;
numbers[2] = 20;
numbers[3] = 30;
numbers[4] = 40;

```


### Vector(동적 배열)

✔ 동적 배열

✔ 전체 크기를 가늠하기 힘든 데이터도 많다! -> 자동으로 크기 조정
- 초기 값을 작게 잡아 배열 생성
- 데이터가 추가 돼서 꽉 채워질 떄마다 늘려준다 (Doubling)
- Python(CPython) 같은 경우 초기에는 2배, 전체적으로는 1.125배
- Java의 ArrayList 같은 경우는 1.5배

✔ 조회: O(1) / 탐색: O(N)

✔ 삭제 / 삽입: O(N)
- 기존 원소들을 이동 시켜줘야된다.

```java
ArrayList<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
```

### Linked List (연결 리스트)

✔ 포인터를 활용해 연결 
- 물리 메모리를 연속적으로 사용하지 않아 관리 용이

✔ 동적으로 새로운 노드 삽입/삭제 용이
- 기존 연결을 끊고 포인터만 바꿔주면 된다

✔ 삽입/삭제: O(1) / 조회: O(N)

```java
class Node {
    int value;
    Node next;

    Node(int value, Node next) {
        this.value = value;
        this.next = next;
    }
}

Node head = new Node(1, new Node(2, new Node(3)));
```

## 2. Stack, Queue

### Stack

✔ LIFO (Last In First Out): 후입 선출

✔ 재귀, 메모리(스택 영역)에서 사용

```java
import java.util.Stack;

Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.push(2);
stack.push(3);

System.out.println(stack); // Output: [3, 2, 1]

System.out.println(stack.peek()); // Output: 3
System.out.println(stack); // Output: [3, 2, 1]

System.out.println(stack.pop()); // Output: 3
System.out.println(stack); // Output: [2, 1]

```

### Queue

✔ FIFO (First In First Out): 선입 선출

✔ BFS, 스케줄링에 사용

```java
import java.util.LinkedList;

LinkedList<Integer> queue = new LinkedList<>();
queue.add(1);
queue.add(2);
queue.add(3);

System.out.println(queue); // Output: [1, 2, 3]

queue.add(4);
System.out.println(queue); // Output: [1, 2, 3, 4]

System.out.println(queue.remove()); // Output: 1
System.out.println(queue); // Output: [2, 3, 4]
```

## 3. Deque

## 4. Priority Queue, Heap

### Priority Queue(우선순위 큐)

✔ 특정 조건(최소, 최대 등)에 따라 우선순위가 높은 요소가 추출되는 자료형

✔ 일반적으로 힙(Heap)을 이용해 구현

✔ 삽입: O(logN)  
✔ 삭제(우선순위): O(logN)  
✔ 조회: O(1)  

```java
import java.util.PriorityQueue;

PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((a, b) -> b - a);
priorityQueue.offer(1);
priorityQueue.offer(2);
priorityQueue.offer(3);

System.out.println(priorityQueue); // Output: [3, 2, 1]

System.out.println(priorityQueue.peek()); // Output: 3

priorityQueue.offer(4);
System.out.println(priorityQueue); // Output: [4, 3, 1, 2]

System.out.println(priorityQueue.poll()); // Output: 4
System.out.println(priorityQueue); // Output: [3, 2, 1]
```

## 5. hash

## 6. graph

## 7. tree 이진트리 완전이진트리 이진탐색트리

## 8. avl / redblack tree

## 9. union-find